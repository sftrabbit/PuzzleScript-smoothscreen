From 1908d30bd8fe8e03e96739f7376172c4a9bc3f29 Mon Sep 17 00:00:00 2001
From: Joseph Mansfield <sftrabbit@gmail.com>
Date: Mon, 12 Oct 2020 17:10:17 +0100
Subject: [PATCH] Add smoothscreen for smooth scrolling

---
 Documentation/levels.html     |   2 +-
 Documentation/prelude.html    |   2 +
 js/codemirror/anyword-hint.js |   3 +-
 js/compiler.js                |  56 +++++++++++++++++
 js/engine.js                  |  16 ++++-
 js/graphics.js                | 112 +++++++++++++++++++++++++++++++++-
 js/inputoutput.js             |  10 ++-
 js/parser.js                  |   2 +-
 8 files changed, 193 insertions(+), 10 deletions(-)

diff --git a/Documentation/levels.html b/Documentation/levels.html
index 275ca0f..4d3fbd6 100644
--- a/Documentation/levels.html
+++ b/Documentation/levels.html
@@ -119,7 +119,7 @@ If you hold CTRL (or, on a Mac, CMD) and left click on the level in the text edi
 <p>
 <h3>What stuff is hard to do?</h3>
 <p>
-Branching.  I have no support for it in terms of this level structure.  If you want a continuous open world you can set <b>zoomscreen</b> or <b>flickscreen</b> in the <a href="prelude.html">prelude</a>.
+Branching.  I have no support for it in terms of this level structure.  If you want a continuous open world you can set <b>zoomscreen</b>, <b>flickscreen</b>, or <b>smoothscreen</b> in the <a href="prelude.html">prelude</a>.
 <p>
 If you can think of an elegant way to implement level branching in the engine, <a href="mailto:analytic@gmail.com">let me know</a>, and I'll consider it : )
 
diff --git a/Documentation/prelude.html b/Documentation/prelude.html
index c9db032..bf41129 100644
--- a/Documentation/prelude.html
+++ b/Documentation/prelude.html
@@ -186,6 +186,8 @@ late [ Temp ] -> [ ]</code></pre>
       <dd>If you write the youtube tag followed by the ID of a youtube video, it will play in the background.  Exported builds using this, obviously enough, will no longer be fully self-contained, but some might like it :)  You'll only hear the music in the exported or shared versions, not in the editor.</dd>
 			<dt>zoomscreen WxH</dt>
 			<dd>Zooms the camera in to a WxH section of the map around the player, centered on the player.</dd>
+      <dt>smoothscreen WxH <i>IxJ speed</i></dt>
+      <dd>Zooms the camera in to a WxH section of the map around the player, centered on the player, and smoothly scrolls to follow the player. The optional argument IxJ (default: 1x1) specifies a boundary in which the player can move without moving the camera. The optional speed argument (default: 0.125) specifies how far the camera will move towards the player each frame as a fraction of the distance to the player. You'll get weird behaviour if the boundary is larger than the screen size or if the speed is less than 0 or greater than 1 (but that's not going to stop you, is it?).</dd>
 		</dl>
 
 
diff --git a/js/codemirror/anyword-hint.js b/js/codemirror/anyword-hint.js
index 1c2e512..8719f69 100644
--- a/js/codemirror/anyword-hint.js
+++ b/js/codemirror/anyword-hint.js
@@ -36,7 +36,8 @@
             ["throttle_movement", "", "For use in conjunction with realtime_interval - this stops you from moving crazy fast - repeated keypresses of the same movement direction will not increase your speed. This doesn't apply to the action button."],
             ["verbose_logging", "", "As you play the game, spits out information about all rules applied as you play"],
             ["youtube", "5MJLi5_dyn0", "If you write the youtube tag followed by the ID of a youtube video, it will play in the background."],
-            ["zoomscreen", "WxH", "Zooms the camera in to a WxH section of the map around the player, centered on the player."]
+            ["zoomscreen", "WxH", "Zooms the camera in to a WxH section of the map around the player, centered on the player."],
+            ["smoothscreen", "WxH [IxJ] [speed]", "Zooms the camera in to a WxH section of the map around the player, centered on the player, and smoothly scrolls to follow the player. The optional argument IxJ (default: 1x1) specifies a boundary in which the player can move without moving the camera. The optional speed argument (default: 0.125) specifies how far the camera will move towards the player each frame as a fraction of the distance to the player."]
         ];
 
         var COLOR_WORDS = [
diff --git a/js/compiler.js b/js/compiler.js
index c90e31b..4be76c9 100644
--- a/js/compiler.js
+++ b/js/compiler.js
@@ -1951,6 +1951,62 @@ function twiddleMetaData(state) {
 		var intcoords = [parseInt(coords[0]),parseInt(coords[1])];
 		newmetadata.zoomscreen=intcoords;
 	}
+	if (newmetadata.smoothscreen!==undefined) {
+		var val = newmetadata.smoothscreen;
+		var args = val.split(/\s+/);
+
+		var validArguments = true
+
+		if (args.length < 1) {
+			logErrorNoLine('smoothscreen given no arguments but expects at least 1: smoothscreen WxH [IxJ [speed]]')
+			validArguments = false
+		} else if (args.length > 3) {
+			logErrorNoLine(`smoothscreen given ${args.length} arguments but expects at most 3: smoothscreen WxH [IxJ [speed]]`)
+			validArguments = false
+		}
+
+		const smoothscreen = {
+			screenSize: { width: 0, height: 0 },
+			boundarySize: { width: 1, height: 1 },
+			cameraSpeed: 0.125
+		}
+
+		const screenSizeMatch = args[0].match(/^(?<width>\d+)x(?<height>\d+)$/)
+		if (screenSizeMatch) {
+			smoothscreen.screenSize.width = parseInt(screenSizeMatch.groups.width)
+			smoothscreen.screenSize.height = parseInt(screenSizeMatch.groups.height)
+		} else {
+			logErrorNoLine(`smoothscreen given first argument ${args[0]} but must be formatted WxH where W and H are integers`)
+			validArguments = false
+		}
+
+		if (args.length > 1) {
+			const boundarySizeMatch = args[1].match(/^(?<width>\d+)x(?<height>\d+)$/)
+			if (boundarySizeMatch) {
+				smoothscreen.boundarySize.width = parseInt(boundarySizeMatch.groups.width)
+				smoothscreen.boundarySize.height = parseInt(boundarySizeMatch.groups.height)
+			} else {
+				logErrorNoLine(`smoothscreen given second argument ${args[1]} but must be formatted IxJ where I and J are integers`)
+				validArguments = false
+			}
+		}
+
+		if (args.length > 2) {
+			const cameraSpeedMatch = args[2].match(/^(?<speed>\d+(\.\d+)?)$/)
+			if (cameraSpeedMatch) {
+				smoothscreen.cameraSpeed = parseFloat(cameraSpeedMatch.groups.speed)
+			} else {
+				logErrorNoLine(`smoothscreen given third argument ${args[2]} but must be a number`)
+				validArguments = false
+			}
+		}
+
+		if (validArguments) {
+			newmetadata.smoothscreen = smoothscreen;
+		} else {
+			delete newmetadata.smoothscreen
+		}
+	}
 
 	state.metadata=newmetadata;	
 }
diff --git a/js/engine.js b/js/engine.js
index 0879f00..d5985bc 100644
--- a/js/engine.js
+++ b/js/engine.js
@@ -414,6 +414,13 @@ function loadLevelFromLevelDat(state,leveldat,randomseed) {
 	            	Math.min(state.metadata.zoomscreen[0],level.width),
 	            	Math.min(state.metadata.zoomscreen[1],level.height)
 	            ];
+	        } else if (state.metadata.smoothscreen!==undefined){
+	            oldflickscreendat=[
+	            	0,
+	            	0,
+	            	Math.min(state.metadata.smoothscreen.screenSize.width,level.width),
+	            	Math.min(state.metadata.smoothscreen.screenSize.height,level.height)
+	            ];
 	        }
         }
 
@@ -751,7 +758,9 @@ function setGameState(_state, command, randomseed) {
 			break;
 		}
 	}
-	
+
+	initSmoothCamera();
+
 	if(command[0] !== "rebuild") {
 		clearInputHistory();
 	}
@@ -763,7 +772,6 @@ function setGameState(_state, command, randomseed) {
 	} else {
 		showAudioButton();
 	}
-	
 }
 
 function RebuildLevelArrays() {
@@ -848,6 +856,7 @@ function restoreLevel(lev) {
 
 var zoomscreen=false;
 var flickscreen=false;
+var smoothscreen=false;
 var screenwidth=0;
 var screenheight=0;
 
@@ -874,6 +883,8 @@ function DoRestart(force) {
     	processInput(-1,true);
 	}
 	
+	initSmoothCamera();
+	
 	level.commandQueue=[];
 	level.commandQueueSourceRules=[];
 	restarting=false;
@@ -2679,6 +2690,7 @@ function nextLevel() {
 	}
 	canvasResize();	
 	clearInputHistory();
+	initSmoothCamera();
 }
 
 function goToTitleScreen(){
diff --git a/js/graphics.js b/js/graphics.js
index 35b9854..c551d39 100644
--- a/js/graphics.js
+++ b/js/graphics.js
@@ -188,6 +188,45 @@ function glyphCount(){
     return count;
 }
 
+var cameraPositionTarget = {
+  x: 0,
+  y: 0
+};
+
+var cameraPosition = {
+  x: 0,
+  y: 0
+};
+
+function initSmoothCamera() {
+    if (state===undefined || state.metadata.smoothscreen===undefined) {
+        return
+    }
+
+    const boundarySize = state.metadata.smoothscreen.boundarySize
+    var playerPositions = getPlayerPositions();
+    if (playerPositions.length>0) {
+        const playerPosition = {
+            x: (playerPositions[0]/(level.height))|0,
+            y: (playerPositions[0]%level.height)|0
+        }
+
+        cameraPositionTarget = {
+            x: Math.min(
+                Math.max(playerPosition.x, Math.floor(screenwidth / 2)),
+                level.width - Math.ceil(screenwidth / 2)
+            ),
+            y: Math.min(
+                Math.max(playerPosition.y, Math.floor(screenheight / 2)),
+                level.height - Math.ceil(screenheight / 2)
+            )
+        }
+
+        cameraPosition.x = cameraPositionTarget.x
+        cameraPosition.y = cameraPositionTarget.y
+    }
+}
+
 function redraw() {
     if (cellwidth===0||cellheight===0) {
         return;
@@ -219,6 +258,11 @@ function redraw() {
         var minj=0;
         var maxj=screenheight;
 
+        var cameraOffset = {
+            x: 0,
+            y: 0
+        }
+
         if (levelEditorOpened) {
             var glyphcount = glyphCount();
             editorRowCount = Math.ceil(glyphcount/(screenwidth-1));
@@ -262,22 +306,80 @@ function redraw() {
                 maxi=oldflickscreendat[2];
                 maxj=oldflickscreendat[3];
             }         
+        } else if (smoothscreen) {
+            const smoothscreenConfig = state.metadata.smoothscreen
+            var playerPositions = getPlayerPositions();
+
+            if (playerPositions.length > 0) {
+                const playerPosition = {
+                    x: (playerPositions[0]/(level.height))|0,
+                    y: (playerPositions[0]%level.height)|0
+                };
+
+                for (const coord of ['x', 'y']) {
+                    const screenDimension = coord === 'x' ? screenwidth : screenheight
+
+                    const dimensionName = coord === 'x' ? 'width' : 'height'
+                    const levelDimension = level[dimensionName]
+                    const boundaryDimension = smoothscreenConfig.boundarySize[dimensionName]
+
+                    const playerVector = playerPosition[coord] - cameraPositionTarget[coord]
+                    const direction = Math.sign(playerVector)
+                    const boundaryVector = direction > 0
+                      ? Math.ceil(boundaryDimension / 2)
+                      : -(Math.floor(boundaryDimension / 2) + 1)
+
+                    if (Math.abs(playerVector) - Math.abs(boundaryVector) >= 0) {
+                        cameraPositionTarget[coord] = Math.min(
+                            Math.max(playerPosition[coord] - boundaryVector + direction, Math.floor(screenDimension / 2)),
+                            levelDimension - Math.ceil(screenDimension / 2)
+                        )
+                    }
+
+                    const cameraTargetVector = cameraPositionTarget[coord] - cameraPosition[coord]
+                    cameraPosition[coord] += cameraTargetVector * smoothscreenConfig.cameraSpeed
+
+                    cameraOffset[coord] = cameraPosition[coord] % 1
+                }
+
+                mini=Math.max(Math.min(Math.floor(cameraPosition.x)-Math.floor(screenwidth/2), level.width-screenwidth),0);
+                minj=Math.max(Math.min(Math.floor(cameraPosition.y)-Math.floor(screenheight/2), level.height-screenheight),0);
+
+                maxi=Math.min(mini+screenwidth,level.width);
+                maxj=Math.min(minj+screenheight,level.height);
+                oldflickscreendat=[mini,minj,maxi,maxj];
+            } else if (oldflickscreendat.length>0) {
+                mini=oldflickscreendat[0];
+                minj=oldflickscreendat[1];
+                maxi=oldflickscreendat[2];
+                maxj=oldflickscreendat[3];
+            }
         }
 	    
 
-        for (var i = mini; i < maxi; i++) {
-            for (var j = minj; j < maxj; j++) {
+        ctx.save();
+        ctx.beginPath();
+        ctx.moveTo(xoffset, yoffset);
+        ctx.lineTo(xoffset + (maxi - mini) * cellwidth, yoffset);
+        ctx.lineTo(xoffset + (maxi - mini) * cellwidth, yoffset + (maxj - minj) * cellwidth);
+        ctx.lineTo(xoffset, yoffset + (maxj - minj) * cellwidth);
+        ctx.clip();
+
+        for (var i = Math.max(mini - 1, 0); i < Math.min(maxi + 1, level.width); i++) {
+            for (var j = Math.max(minj - 1, 0); j < Math.min(maxj + 1, level.height); j++) {
                 var posIndex = j + i * level.height;
                 var posMask = level.getCellInto(posIndex,_o12);                
                 for (var k = 0; k < state.objectCount; k++) {
                     if (posMask.get(k) != 0) {                  
                         var sprite = spriteimages[k];
-                        ctx.drawImage(sprite, xoffset + (i-mini) * cellwidth, yoffset + (j-minj) * cellheight);
+                        ctx.drawImage(sprite, xoffset + (i-mini-cameraOffset.x) * cellwidth, yoffset + (j-minj-cameraOffset.y) * cellheight);
                     }
                 }
             }
         }
 
+        ctx.restore()
+
 	    if (levelEditorOpened) {
 	    	drawEditorIcons();
 	    }
@@ -347,6 +449,7 @@ function canvasResize() {
     if (state!==undefined){
         flickscreen=state.metadata.flickscreen!==undefined;
         zoomscreen=state.metadata.zoomscreen!==undefined;
+        smoothscreen=state.metadata.smoothscreen!==undefined;
 	    if (levelEditorOpened) {
             screenwidth+=2;
             var glyphcount = glyphCount();
@@ -358,6 +461,9 @@ function canvasResize() {
 	    } else if (zoomscreen) {
 	        screenwidth=state.metadata.zoomscreen[0];
 	        screenheight=state.metadata.zoomscreen[1];
+	    } else if (smoothscreen) {
+	        screenwidth=state.metadata.smoothscreen.screenSize.width;
+	        screenheight=state.metadata.smoothscreen.screenSize.height;
 	    }
 	}
 
diff --git a/js/inputoutput.js b/js/inputoutput.js
index 1b8ac25..204f79e 100644
--- a/js/inputoutput.js
+++ b/js/inputoutput.js
@@ -704,6 +704,8 @@ function checkKey(e,justPressed) {
 
 
 function update() {
+    let draw = false;
+
     timer+=deltatime;
     input_throttle_timer+=deltatime;
     if (quittingTitleScreen) {
@@ -715,7 +717,7 @@ function update() {
     if (againing) {
         if (timer>againinterval&&messagetext.length==0) {
             if (processInput(-1)) {
-                redraw();
+                draw = true;
                 keyRepeatTimer=0;
                 autotick=0;
             }
@@ -761,10 +763,14 @@ function update() {
             autotick=0;
             pushInput("tick");
             if (processInput(-1)) {
-                redraw();
+                draw = true;
             }
         }
     }
+
+    if (draw || (state !== undefined && state.metadata.smoothscreen !== undefined)) {
+      redraw();
+    }
 }
 
 // Lights, cameraâ€¦function!
diff --git a/js/parser.js b/js/parser.js
index 28abe03..19b85f9 100644
--- a/js/parser.js
+++ b/js/parser.js
@@ -1152,7 +1152,7 @@ var codeMirrorFn = function() {
 		                    if (match!==null) {
 		                    	var token = match[0].trim();
 		                    	if (sol) {
-		                    		if (['title','author','homepage','background_color','text_color','key_repeat_interval','realtime_interval','again_interval','flickscreen','zoomscreen','color_palette','youtube'].indexOf(token)>=0) {
+		                    		if (['title','author','homepage','background_color','text_color','key_repeat_interval','realtime_interval','again_interval','flickscreen','zoomscreen','smoothscreen','color_palette','youtube'].indexOf(token)>=0) {
 		                    			
                                         if (token==='youtube' || token==='author' || token==='title') {
                                             stream.string=mixedCase;
-- 
2.25.1

